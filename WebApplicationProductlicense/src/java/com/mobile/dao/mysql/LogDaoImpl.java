/*
 * This file was generated - do not edit it directly !!
 * Generated by AuDAO tool, a product of Spolecne s.r.o.
 * For more information please visit http://www.spoledge.com
 */
package com.mobile.dao.mysql;


import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;

import java.util.ArrayList;

import com.spoledge.audao.db.dao.AbstractDaoImpl;
import com.spoledge.audao.db.dao.DBException;
import com.spoledge.audao.db.dao.DaoException;


import com.mobile.dao.LogDao;
import com.mobile.dto.Log;


/**
 * This is the DAO imlementation class.
 *
 * @author generated
 */
public class LogDaoImpl extends AbstractDaoImpl<Log> implements LogDao {

    private static final String TABLE_NAME = "log";

    protected static final String SELECT_COLUMNS = "log_id, level, logger, message, sequence, sourceClass, sourceMethod, threadID, timeEntered";

    protected static final String PK_CONDITION = "log_id=?";

    private static final String SQL_INSERT = "INSERT INTO log (level,logger,message,sequence,sourceClass,sourceMethod,threadID,timeEntered) VALUES (?,?,?,?,?,?,?,?)";

    public LogDaoImpl( Connection conn ) {
        super( conn );
    }

    /**
     * Finds a record identified by its primary key.
     * @return the record found or null
     */
    public Log findByPrimaryKey( int logId ) {
        return findOne( PK_CONDITION, logId);
    }

    /**
     * Finds records ordered by timeEntered.
     */
    public Log[] findAll( ) {
        return findManyArray( "1=1 ORDER BY timeEntered", 0, -1);
    }

    /**
     * Deletes records.
     * @return the number of records deleted
     */
    public int deleteAll( ) throws DaoException {
        return deleteMany( null);
    }

    /**
     * Inserts a new record.
     * @return the generated primary key - logId
     */
    public int insert( Log dto ) throws DaoException {
        PreparedStatement stmt = null;
        ResultSet rs = null;

        debugSql( SQL_INSERT, dto );

        try {
            stmt = conn.prepareStatement( SQL_INSERT, PreparedStatement.RETURN_GENERATED_KEYS );

            if ( dto.getLevel() == null ) {
                throw new DaoException("Value of column 'level' cannot be null");
            }
            stmt.setInt( 1, dto.getLevel() );

            if ( dto.getLogger() == null ) {
                throw new DaoException("Value of column 'logger' cannot be null");
            }
            checkMaxLength( "logger", dto.getLogger(), 64 );
            stmt.setString( 2, dto.getLogger() );

            if ( dto.getMessage() == null ) {
                throw new DaoException("Value of column 'message' cannot be null");
            }
            checkMaxLength( "message", dto.getMessage(), 255 );
            stmt.setString( 3, dto.getMessage() );

            if ( dto.getSequence() == null ) {
                throw new DaoException("Value of column 'sequence' cannot be null");
            }
            stmt.setInt( 4, dto.getSequence() );

            if ( dto.getSourceClass() == null ) {
                throw new DaoException("Value of column 'sourceClass' cannot be null");
            }
            checkMaxLength( "sourceClass", dto.getSourceClass(), 64 );
            stmt.setString( 5, dto.getSourceClass() );

            if ( dto.getSourceMethod() == null ) {
                throw new DaoException("Value of column 'sourceMethod' cannot be null");
            }
            checkMaxLength( "sourceMethod", dto.getSourceMethod(), 32 );
            stmt.setString( 6, dto.getSourceMethod() );

            if ( dto.getThreadID() == null ) {
                throw new DaoException("Value of column 'threadID' cannot be null");
            }
            stmt.setInt( 7, dto.getThreadID() );

            if ( dto.getTimeEntered() == null ) {
                dto.setTimeEntered( new Timestamp( System.currentTimeMillis()));
            }
            stmt.setTimestamp( 8, dto.getTimeEntered() );

            int n = stmt.executeUpdate();

            rs = stmt.getGeneratedKeys();
            rs.next();

            dto.setLogId( rs.getInt( 1 ));

            return dto.getLogId();
        }
        catch (SQLException e) {
            errorSql( e, SQL_INSERT, dto );
            handleException( e );
            throw new DBException( e );
        }
        finally {
            if (rs != null) try { rs.close(); } catch (SQLException e) {}
            if (stmt != null) try { stmt.close(); } catch (SQLException e) {}
        }
    }

    /**
     * Updates one record found by primary key.
     * @return true iff the record was really updated (=found and any change was really saved)
     */
    public boolean update( int logId, Log dto ) throws DaoException {
        StringBuffer sb = new StringBuffer();
        ArrayList<Object> params = new ArrayList<Object>();

        if ( dto.getLogger() != null ) {
            checkMaxLength( "logger", dto.getLogger(), 64 );
            sb.append( "logger=?" );
            params.add( dto.getLogger());
        }

        if ( dto.getMessage() != null ) {
            if (sb.length() > 0) {
                sb.append( ", " );
            }

            checkMaxLength( "message", dto.getMessage(), 255 );
            sb.append( "message=?" );
            params.add( dto.getMessage());
        }

        if ( dto.getSourceClass() != null ) {
            if (sb.length() > 0) {
                sb.append( ", " );
            }

            checkMaxLength( "sourceClass", dto.getSourceClass(), 64 );
            sb.append( "sourceClass=?" );
            params.add( dto.getSourceClass());
        }

        if ( dto.getSourceMethod() != null ) {
            if (sb.length() > 0) {
                sb.append( ", " );
            }

            checkMaxLength( "sourceMethod", dto.getSourceMethod(), 32 );
            sb.append( "sourceMethod=?" );
            params.add( dto.getSourceMethod());
        }

        if (sb.length() == 0) {
            return false;
        }

        params.add( logId );

        Object[] oparams = new Object[ params.size() ];

        return updateOne( sb.toString(), PK_CONDITION, params.toArray( oparams ));
    }

    /**
     * Returns the table name.
     */
    public String getTableName() {
        return TABLE_NAME;
    }

    protected String getSelectColumns() {
        return SELECT_COLUMNS;
    }

    protected Log fetch( ResultSet rs ) throws SQLException {
        Log dto = new Log();
        dto.setLogId( rs.getInt( 1 ));
        dto.setLevel( rs.getInt( 2 ));
        dto.setLogger( rs.getString( 3 ));
        dto.setMessage( rs.getString( 4 ));
        dto.setSequence( rs.getInt( 5 ));
        dto.setSourceClass( rs.getString( 6 ));
        dto.setSourceMethod( rs.getString( 7 ));
        dto.setThreadID( rs.getInt( 8 ));
        dto.setTimeEntered( rs.getTimestamp( 9 ));

        return dto;
    }

    protected Log[] toArray(ArrayList<Log> list ) {
        Log[] ret = new Log[ list.size() ];
        return list.toArray( ret );
    }

}
